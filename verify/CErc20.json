{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/Comptroller/Interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IComptroller {\n  /*** Assets You Are In ***/\n  function isComptroller() external view returns (bool);\n\n  function markets(address) external view returns (bool, uint8, bool);\n\n  function getAllMarkets() external view returns (address[] memory);\n\n  function oracle() external view returns (address);\n\n  function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n  function exitMarket(address cToken) external returns (uint256);\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function getAccountLiquidity(address) external view returns (uint256, uint256, uint256);\n\n  // function getAssetsIn(address) external view returns (ICToken[] memory);\n  function claimComp(address) external;\n\n  function compAccrued(address) external view returns (uint256);\n\n  function getAssetsIn(address account) external view returns (address[] memory);\n\n  function timelock() external view returns (address);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external returns (uint256);\n\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n  function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external returns (uint256);\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidationIncentiveMantissa() external view returns (uint256, uint256, uint256);\n\n  function isListed(address asset) external view returns (bool);\n\n  function marketGroupId(address asset) external view returns (uint8);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  ) external view returns (uint256, uint256, uint256);\n\n  // function _getMarketBorrowCap(address cToken) external view returns (uint256);\n\n  /// @notice Emitted when an action is paused on a market\n  event ActionPaused(address cToken, string action, bool pauseState);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(address indexed cToken, uint256 newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  event RemoveAssetGroup(uint8 indexed groupId, uint8 equalAssetsGroupNum);\n\n  /// @notice AssetGroup, contains information of groupName and rateMantissas\n  struct AssetGroup {\n    uint8 groupId;\n    string groupName;\n    uint256 intraCRateMantissa;\n    uint256 intraMintRateMantissa;\n    uint256 intraSuRateMantissa;\n    uint256 interCRateMantissa;\n    uint256 interSuRateMantissa;\n  }\n\n  function getAssetGroupNum() external view returns (uint8);\n\n  function getAssetGroup(uint8 groupId) external view returns (AssetGroup memory);\n\n  function _getMintPaused(address cToken) external returns (bool);\n\n  function _getTransferPaused() external view returns (bool);\n\n  function _getBorrowPaused(address cToken) external view returns (bool);\n\n  function _getSeizePaused() external view returns (bool);\n\n  function getCompAddress() external view returns (address);\n\n  function _getMarketBorrowCap(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IPriceOracle {\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/CToken/CErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport './CToken.sol';\nimport './Interfaces/ICErc20.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '../ITimelock.sol';\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CErc20 is CToken, ICErc20, Initializable {\n  using CarefulMath for uint256;\n  using TokenErrorReporter for Error;\n  using Exponential for Exp;\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param admin_ Address of the administrator of this token\n   */\n  function initialize(\n    address underlying_,\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_,\n    uint256 discountRateMantissa_\n  ) public initializer {\n    // CToken initialize does the bulk of the work\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      true,\n      admin_,\n      discountRateMantissa_\n    );\n\n    isCEther = false;\n\n    // Set underlying and sanity check it\n    require(underlying_ != address(0), 'Address is Zero!');\n    underlying = underlying_;\n    // ICToken(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external override returns (uint256) {\n    (uint256 err, ) = mintInternal(mintAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external override returns (uint256) {\n    return redeemInternal(redeemTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external override returns (uint256) {\n    return redeemUnderlyingInternal(redeemAmount);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external override returns (uint256) {\n    return borrowInternal(borrowAmount);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external override returns (uint256) {\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being paid off\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override returns (uint256) {\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external override returns (uint256) {\n    (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return err;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(address token) external override {\n    require(address(token) != underlying, 'CErc20::sweepToken: can not sweep underlying token');\n    uint256 underlyingBalanceBefore = ICToken(underlying).balanceOf(address(this));\n    uint256 balance = ICToken(token).balanceOf(address(this));\n    ICToken(token).transfer(admin, balance);\n    uint256 underlyingBalanceAfter = ICToken(underlying).balanceOf(address(this));\n    require(underlyingBalanceBefore == underlyingBalanceAfter, 'underlyingBalance error');\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @param addAmount The amount fo underlying token to add as reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint256 addAmount) external override returns (uint256) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint256) {\n    // ICToken token = ICToken(underlying);\n    // return token.balanceOf(address(this));\n    return underlyingBalance;\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n    ICToken token = ICToken(underlying);\n    uint256 balanceBefore = ICToken(underlying).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, 'TOKEN_TRANSFER_IN_FAILED');\n\n    // Calculate the amount that was *actually* transferred\n    uint256 balanceAfter = ICToken(underlying).balanceOf(address(this));\n    require(balanceAfter >= balanceBefore, 'TOKEN_TRANSFER_IN_OVERFLOW');\n    uint256 finalAmount = balanceAfter - balanceBefore;\n    underlyingBalance += finalAmount;\n    return finalAmount; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(address payable to, uint256 amount) internal virtual override {\n    ICToken token = ICToken(underlying);\n    token.transfer(to, amount);\n    underlyingBalance -= amount;\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, 'TOKEN_TRANSFER_OUT_FAILED');\n  }\n\n  function transferToTimelock(bool isBorrow, address to, uint256 amount) internal virtual override {\n    address timelock = IComptroller(comptroller).timelock();\n    if (ITimelock(timelock).isSupport(underlying)) {\n      doTransferOut(payable(timelock), amount);\n      ITimelock.TimeLockActionType actionType = isBorrow\n        ? ITimelock.TimeLockActionType.BORROW\n        : ITimelock.TimeLockActionType.REDEEM;\n      ITimelock(timelock).createAgreement(actionType, underlying, amount, to);\n    } else {\n      doTransferOut(payable(to), amount);\n    }\n  }\n    function accrueInterest() public virtual override returns (uint256) {\n    /* Remember the initial block number */\n    uint256 currentBlockNumber = getBlockNumber();\n    uint256 accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Read the previous values out of storage */\n    uint256 cashPrior = getCashPrior();\n    uint256 borrowsPrior = totalBorrows;\n    uint256 reservesPrior = totalReserves;\n    uint256 borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint256 borrowRateMantissa = IInterestRateModel(interestRateModel).getBorrowRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior\n    );\n    if (3 > BORROW_RATE_MAX_MANTISSA) {\n      // Error.TOKEN_ERROR.failOpaque(FailureInfo.BORROW_RATE_ABSURDLY_HIGH, borrowRateMantissa);\n      borrowRateMantissa = BORROW_RATE_MAX_MANTISSA;\n    }\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    (MathError mathErr, uint256 blockDelta) = currentBlockNumber.subUInt(accrualBlockNumberPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.COULD_NOT_CACULATE_BLOCK_DELTA);\n    }\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor;\n    uint256 interestAccumulated;\n    uint256 totalBorrowsNew;\n    uint256 totalReservesNew;\n    uint256 borrowIndexNew;\n\n    (mathErr, simpleInterestFactor) = Exp({mantissa: borrowRateMantissa}).mulScalar(blockDelta);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(\n        FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        uint256(mathErr)\n      );\n    }\n\n    (mathErr, interestAccumulated) = simpleInterestFactor.mulScalarTruncate(borrowsPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(\n        FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        uint256(mathErr)\n      );\n    }\n\n    (mathErr, totalBorrowsNew) = interestAccumulated.addUInt(borrowsPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint256(mathErr));\n    }\n\n    (mathErr, totalReservesNew) = Exp({mantissa: reserveFactorMantissa}).mulScalarTruncateAddUInt(\n      interestAccumulated,\n      reservesPrior\n    );\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint256(mathErr));\n    }\n\n    (mathErr, borrowIndexNew) = simpleInterestFactor.mulScalarTruncateAddUInt(borrowIndexPrior, borrowIndexPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint256(mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n}\n"
    },
    "contracts/CToken/CToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../Comptroller/Interfaces/IComptroller.sol';\nimport '../Comptroller/Interfaces/IPriceOracle.sol';\nimport './Interfaces/IInterestRateModel.sol';\nimport './TokenErrorReporter.sol';\nimport './CTokenStorage.sol';\nimport '../Exponential/Exponential.sol';\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenStorage {\n  using Exponential for uint256;\n  using Exponential for Exp;\n  using ExponentialNoError for uint256;\n  using ExponentialNoError for Exp;\n  using CarefulMath for uint256;\n  using TokenErrorReporter for Error;\n\n  modifier onlyAdmin() {\n    // Check caller is admin\n    require(msg.sender == admin, 'UNAUTHORIZED');\n    _;\n  }\n\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   */\n  function initialize(\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    bool isCToken_,\n    address payable _admin,\n    uint256 discountRateMantissa_\n  ) internal {\n    admin = _admin;\n    require(accrualBlockNumber == 0 && borrowIndex == 0, 'MMOB'); // market may only be initialized once\n\n    isCToken = isCToken_;\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(initialExchangeRateMantissa > 0, 'IERM'); // initial exchange rate must be greater than zero\n\n    discountRateMantissa = discountRateMantissa_;\n    require(discountRateMantissa > 0 && discountRateMantissa <= 1e18, 'RMI'); // rate must in [0,100]\n\n    // Set the comptroller\n    // Set market's comptroller to newComptroller\n    comptroller = comptroller_;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(address(0), comptroller_);\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = 1e18;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    interestRateModel = interestRateModel_;\n    emit NewMarketInterestRateModel(address(0), interestRateModel_);\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\n    /* Fail if transfer not allowed */\n    uint256 allowed = IComptroller(comptroller).transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      Error.BAD_INPUT.fail(FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint256 startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = uint256(0);\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    MathError mathErr;\n    uint256 allowanceNew;\n    uint256 srcTokensNew;\n    uint256 dstTokensNew;\n\n    (mathErr, allowanceNew) = startingAllowance.subUInt(tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    (mathErr, srcTokensNew) = accountTokens[src].subUInt(tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.TRANSFER_NOT_ENOUGH);\n    }\n\n    (mathErr, dstTokensNew) = accountTokens[dst].addUInt(tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.TRANSFER_TOO_MUCH);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != uint256(0)) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint256) {\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n    (MathError mErr, uint256 balance) = exchangeRate.mulScalarTruncate(accountTokens[owner]);\n    if (mErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.BALANCE_COULD_NOT_BE_CALCULATED);\n    }\n    return balance;\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256, uint256) {\n    uint256 cTokenBalance = accountTokens[account];\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n\n    MathError mErr;\n\n    (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n    if (mErr != MathError.NO_ERROR) {\n      return (uint256(Error.MATH_ERROR), 0, 0, 0);\n    }\n\n    (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (mErr != MathError.NO_ERROR) {\n      return (uint256(Error.MATH_ERROR), 0, 0, 0);\n    }\n\n    return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view returns (uint256) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint256) {\n    return IInterestRateModel(interestRateModel).getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint256) {\n    return\n      IInterestRateModel(interestRateModel).getSupplyRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves,\n        reserveFactorMantissa\n      );\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view override returns (uint256) {\n    (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n    if (err != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.BORROW_BALANCE_STORED_INTERNAL_FAILED);\n    }\n    return result;\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n    /* Note: we do not assert that the market is up to date */\n    MathError mathErr;\n    uint256 principalTimesIndex;\n    uint256 result;\n\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    (mathErr, principalTimesIndex) = borrowSnapshot.principal.mulUInt(borrowIndex);\n    if (mathErr != MathError.NO_ERROR) {\n      return (mathErr, 0);\n    }\n\n    (mathErr, result) = principalTimesIndex.divUInt(borrowSnapshot.interestIndex);\n    if (mathErr != MathError.NO_ERROR) {\n      return (mathErr, 0);\n    }\n\n    return (MathError.NO_ERROR, result);\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant returns (uint256) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint256) {\n    (MathError err, uint256 result) = exchangeRateStoredInternal();\n    if (err != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.EXCHANGE_RATE_STORED_INTERNAL_FAILED);\n    }\n    return result;\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return (error code, calculated exchange rate scaled by 1e18)\n   */\n  function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n    if (!isCToken) {\n      return (MathError.NO_ERROR, initialExchangeRateMantissa);\n    }\n\n    uint256 _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return (MathError.NO_ERROR, initialExchangeRateMantissa);\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint256 totalCash = getCashPrior();\n      uint256 cashPlusBorrowsMinusReserves;\n      Exp memory exchangeRate;\n      MathError mathErr;\n\n      (mathErr, cashPlusBorrowsMinusReserves) = totalCash.addThenSubUInt(totalBorrows, totalReserves);\n      if (mathErr != MathError.NO_ERROR) {\n        return (mathErr, 0);\n      }\n\n      (mathErr, exchangeRate) = cashPlusBorrowsMinusReserves.getExp(_totalSupply);\n      if (mathErr != MathError.NO_ERROR) {\n        return (mathErr, 0);\n      }\n\n      return (MathError.NO_ERROR, exchangeRate.mantissa);\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint256) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint256) {\n    /* Remember the initial block number */\n    uint256 currentBlockNumber = getBlockNumber();\n    uint256 accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Read the previous values out of storage */\n    uint256 cashPrior = getCashPrior();\n    uint256 borrowsPrior = totalBorrows;\n    uint256 reservesPrior = totalReserves;\n    uint256 borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint256 borrowRateMantissa = IInterestRateModel(interestRateModel).getBorrowRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior\n    );\n    if (borrowRateMantissa > BORROW_RATE_MAX_MANTISSA) {\n      // Error.TOKEN_ERROR.failOpaque(FailureInfo.BORROW_RATE_ABSURDLY_HIGH, borrowRateMantissa);\n      borrowRateMantissa = BORROW_RATE_MAX_MANTISSA;\n    }\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    (MathError mathErr, uint256 blockDelta) = currentBlockNumber.subUInt(accrualBlockNumberPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.COULD_NOT_CACULATE_BLOCK_DELTA);\n    }\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor;\n    uint256 interestAccumulated;\n    uint256 totalBorrowsNew;\n    uint256 totalReservesNew;\n    uint256 borrowIndexNew;\n\n    (mathErr, simpleInterestFactor) = Exp({mantissa: borrowRateMantissa}).mulScalar(blockDelta);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(\n        FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        uint256(mathErr)\n      );\n    }\n\n    (mathErr, interestAccumulated) = simpleInterestFactor.mulScalarTruncate(borrowsPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(\n        FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        uint256(mathErr)\n      );\n    }\n\n    (mathErr, totalBorrowsNew) = interestAccumulated.addUInt(borrowsPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint256(mathErr));\n    }\n\n    (mathErr, totalReservesNew) = Exp({mantissa: reserveFactorMantissa}).mulScalarTruncateAddUInt(\n      interestAccumulated,\n      reservesPrior\n    );\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint256(mathErr));\n    }\n\n    (mathErr, borrowIndexNew) = simpleInterestFactor.mulScalarTruncateAddUInt(borrowIndexPrior, borrowIndexPrior);\n    if (mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint256(mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintInternal(uint256 mintAmount) internal nonReentrant returns (uint256, uint256) {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    return mintFresh(msg.sender, mintAmount);\n  }\n\n  struct MintLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 mintTokens;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n    uint256 actualMintAmount;\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintFresh(address minter, uint256 mintAmount) internal returns (uint256, uint256) {\n    /* Fail if mint not allowed */\n    uint256 allowed = IComptroller(comptroller).mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.MINT_FRESHNESS_CHECK);\n    }\n\n    MintLocalVars memory vars;\n\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    (vars.mathErr, vars.mintTokens) = vars.actualMintAmount.divScalarByExpTruncate(\n      Exp({mantissa: vars.exchangeRateMantissa})\n    );\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED);\n    }\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = totalSupply.addUInt(vars.mintTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = accountTokens[minter].addUInt(vars.mintTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED);\n    }\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[minter] = vars.accountTokensNew;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n    emit Transfer(address(this), minter, vars.mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n    return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant returns (uint256) {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(payable(msg.sender), redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant returns (uint256) {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(payable(msg.sender), 0, redeemAmount);\n  }\n\n  struct RedeemLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 redeemTokens;\n    uint256 redeemAmount;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemFresh(\n    address payable redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n  ) internal returns (uint256) {\n    if (redeemTokensIn != 0 && redeemAmountIn != 0) {\n      Error.BAD_INPUT.fail(FailureInfo.ONE_OF_REDEEM_TOKENS_IN_OR_REDEEM_AMOUNT_IN_MUST_BE_ZERO);\n    }\n    RedeemLocalVars memory vars;\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      vars.redeemTokens = redeemTokensIn;\n\n      (vars.mathErr, vars.redeemAmount) = Exp({mantissa: vars.exchangeRateMantissa}).mulScalarTruncate(redeemTokensIn);\n      if (vars.mathErr != MathError.NO_ERROR) {\n        Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n\n      (vars.mathErr, vars.redeemTokens) = redeemAmountIn.divScalarByExpTruncate(\n        Exp({mantissa: vars.exchangeRateMantissa})\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n\n      vars.redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = IComptroller(comptroller).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n\n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = totalSupply.subUInt(vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = accountTokens[redeemer].subUInt(vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (isCToken && (getCashPrior() < vars.redeemAmount)) {\n      Error.TOKEN_INSUFFICIENT_CASH.fail(FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    // doTransferOut(redeemer, vars.redeemAmount);\n    transferToTimelock(false, redeemer, vars.redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    /* We call the defense hook */\n    IComptroller(comptroller).redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function redeemAndTransferFresh(address payable redeemer, uint256 redeemTokensIn) internal returns (uint256) {\n    if (redeemTokensIn != 0) {\n      Error.BAD_INPUT.fail(FailureInfo.ONE_OF_REDEEM_TOKENS_IN_OR_REDEEM_AMOUNT_IN_MUST_BE_ZERO);\n    }\n    RedeemLocalVars memory vars;\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    /*\n     * We calculate the exchange rate and the amount of underlying to be redeemed:\n     *  redeemTokens = redeemTokensIn\n     *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n     */\n    vars.redeemTokens = redeemTokensIn;\n\n    (vars.mathErr, vars.redeemAmount) = Exp({mantissa: vars.exchangeRateMantissa}).mulScalarTruncate(redeemTokensIn);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = IComptroller(comptroller).redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n\n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = totalSupply.subUInt(vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = accountTokens[redeemer].subUInt(vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (isCToken && (getCashPrior() < vars.redeemAmount)) {\n      Error.TOKEN_INSUFFICIENT_CASH.fail(FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, vars.redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    /* We call the defense hook */\n    IComptroller(comptroller).redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant returns (uint256) {\n    accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    return borrowFresh(payable(msg.sender), borrowAmount);\n  }\n\n  struct BorrowLocalVars {\n    MathError mathErr;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowFresh(address payable borrower, uint256 borrowAmount) internal returns (uint256) {\n    /* Fail if borrow not allowed */\n    uint256 allowed = IComptroller(comptroller).borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.BORROW_FRESHNESS_CHECK);\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    if (isCToken && (getCashPrior() < borrowAmount)) {\n      Error.TOKEN_INSUFFICIENT_CASH.fail(FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n    }\n\n    BorrowLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowsNew = accountBorrows + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountBorrowsNew) = vars.accountBorrows.addUInt(borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(\n        FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        uint256(vars.mathErr)\n      );\n    }\n\n    (vars.mathErr, vars.totalBorrowsNew) = totalBorrows.addUInt(borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    // doTransferOut(borrower, borrowAmount);\n    transferToTimelock(true, borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant returns (uint256, uint256) {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being paid off\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowBehalfInternal(\n    address borrower,\n    uint256 repayAmount\n  ) internal nonReentrant returns (uint256, uint256) {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  struct RepayBorrowLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 repayAmount;\n    uint256 borrowerIndex;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n    uint256 actualRepayAmount;\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being paid off\n   * @param repayAmount the amount of underlying tokens being returned\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256, uint256) {\n    /* Fail if repayBorrow not allowed */\n    uint256 allowed = IComptroller(comptroller).repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n    }\n\n    RepayBorrowLocalVars memory vars;\n\n    /* We remember the original borrowerIndex for verification purposes */\n    vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(\n        FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        uint256(vars.mathErr)\n      );\n    }\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    if (repayAmount == ~uint256(0)) {\n      vars.repayAmount = vars.accountBorrows;\n    } else {\n      vars.repayAmount = repayAmount;\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    (vars.mathErr, vars.accountBorrowsNew) = vars.accountBorrows.subUInt(vars.actualRepayAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED);\n    }\n\n    (vars.mathErr, vars.totalBorrowsNew) = totalBorrows.subUInt(vars.actualRepayAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.fail(FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n    }\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n    return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) internal nonReentrant returns (uint256, uint256) {\n    accrueInterest();\n    ICToken(cTokenCollateral).accrueInterest();\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) internal returns (uint256, uint256) {\n    /* Fail if liquidate not allowed */\n    uint256 allowed = liquidateBorrowAllowed(address(cTokenCollateral), liquidator, borrower, repayAmount);\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (ICToken(cTokenCollateral).accrualBlockNumber() != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      Error.INVALID_ACCOUNT_PAIR.fail(FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      Error.INVALID_CLOSE_AMOUNT_REQUESTED.fail(FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n    }\n\n    if (repayAmount == ~uint256(0)) {\n      Error.INVALID_CLOSE_AMOUNT_REQUESTED.fail(FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n    }\n\n    /* Fail if repayBorrow fails */\n    (, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    (, uint8 repayTokenGroupId, ) = IComptroller(comptroller).markets(address(this));\n    (, uint8 seizeTokenGroupId, ) = IComptroller(comptroller).markets(cTokenCollateral);\n\n    (\n      uint256 heteroLiquidationIncentive,\n      uint256 homoLiquidationIncentive,\n      uint256 sutokenLiquidationIncentive\n    ) = IComptroller(comptroller).liquidationIncentiveMantissa();\n\n    // default is repaying heterogeneous assets\n    uint256 incentiveMantissa = heteroLiquidationIncentive;\n    if (repayTokenGroupId == seizeTokenGroupId) {\n      if (CToken(address(this)).isCToken() == false) {\n        // repaying sutoken\n        incentiveMantissa = sutokenLiquidationIncentive;\n      } else {\n        // repaying homogeneous assets\n        incentiveMantissa = homoLiquidationIncentive;\n      }\n    }\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (, uint256 seizeTokens) = liquidateCalculateSeizeTokens(cTokenCollateral, actualRepayAmount, incentiveMantissa);\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    if (ICToken(cTokenCollateral).balanceOf(borrower) < seizeTokens) {\n      Error.TOKEN_ERROR.fail(FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n    }\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    if (cTokenCollateral == address(this)) {\n      seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      ICToken(cTokenCollateral).seize(liquidator, borrower, seizeTokens);\n    }\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n    return (uint256(Error.NO_ERROR), actualRepayAmount);\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override nonReentrant returns (uint256) {\n    return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n  }\n\n  struct SeizeInternalLocalVars {\n    MathError mathErr;\n    uint256 borrowerTokensNew;\n    uint256 liquidatorTokensNew;\n    uint256 liquidatorSeizeTokens;\n    uint256 protocolSeizeTokens;\n    uint256 protocolSeizeAmount;\n    uint256 exchangeRateMantissa;\n    uint256 totalReservesNew;\n    uint256 totalSupplyNew;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) internal returns (uint256) {\n    /* Fail if seize not allowed */\n    uint256 allowed = IComptroller(comptroller).seizeAllowed(\n      address(this),\n      seizerToken,\n      liquidator,\n      borrower,\n      seizeTokens\n    );\n    if (allowed != 0) {\n      Error.COMPTROLLER_REJECTION.failOpaque(FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      Error.INVALID_ACCOUNT_PAIR.fail(FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n    }\n\n    SeizeInternalLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    (vars.mathErr, vars.borrowerTokensNew) = accountTokens[borrower].subUInt(seizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    vars.protocolSeizeTokens = seizeTokens.mul_(Exp({mantissa: protocolSeizeShareMantissa}));\n    vars.liquidatorSeizeTokens = seizeTokens.sub_(vars.protocolSeizeTokens);\n\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    vars.protocolSeizeAmount = Exp({mantissa: vars.exchangeRateMantissa}).mul_ScalarTruncate(vars.protocolSeizeTokens);\n\n    vars.totalReservesNew = totalReserves.add_(vars.protocolSeizeAmount);\n    vars.totalSupplyNew = totalSupply.sub_(vars.protocolSeizeTokens);\n\n    (vars.mathErr, vars.liquidatorTokensNew) = accountTokens[liquidator].addUInt(vars.liquidatorSeizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      Error.MATH_ERROR.failOpaque(FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    totalReserves = vars.totalReservesNew;\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[borrower] = vars.borrowerTokensNew;\n    accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n    emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n    redeemAndTransferFresh(payable(liquidator), vars.liquidatorSeizeTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address payable newPendingAdmin) external override onlyAdmin returns (uint256) {\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    require(newPendingAdmin != address(0), 'AIZ'); // Address is Zero\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() external override returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      Error.UNAUTHORIZED.fail(FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = payable(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Admin function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(address newComptroller) public override onlyAdmin returns (uint256) {\n    address oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(IComptroller(newComptroller).isComptroller(), 'MMRF'); // market method returned false\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant returns (uint256) {\n    accrueInterest();\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal onlyAdmin returns (uint256) {\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n    }\n\n    // Check newReserveFactor  maxReserveFactor\n    if (newReserveFactorMantissa > RESERVE_FACTOR_MAX_MANTISSA) {\n      Error.BAD_INPUT.fail(FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n    }\n\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring from msg.sender\n   * @param addAmount Amount of addition to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReservesInternal(uint256 addAmount) internal nonReentrant returns (uint256) {\n    accrueInterest();\n    // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n    (uint256 error, ) = _addReservesFresh(addAmount);\n    return error;\n  }\n\n  /**\n   * @notice Add reserves by transferring from caller\n   * @dev Requires fresh interest accrual\n   * @param addAmount Amount of addition to reserves\n   * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n   */\n  function _addReservesFresh(uint256 addAmount) internal returns (uint256, uint256) {\n    // totalReserves + actualAddAmount\n    uint256 totalReservesNew;\n    uint256 actualAddAmount;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.ADD_RESERVES_FRESH_CHECK);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the caller and the addAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional addAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *  it returns the amount actually transferred, in case of a fee.\n     */\n\n    actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n    totalReservesNew = totalReserves + actualAddAmount;\n\n    /* Revert on overflow */\n    if (totalReservesNew < totalReserves) {\n      Error.MATH_ERROR.fail(FailureInfo.ADD_RESERVES_UNEXPECTED_OVERFLOW);\n    }\n\n    // Store reserves[n+1] = reserves[n] + actualAddAmount\n    totalReserves = totalReservesNew;\n\n    /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n    emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n    /* Return (NO_ERROR, actualAddAmount) */\n    return (uint256(Error.NO_ERROR), actualAddAmount);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint256 reduceAmount) external override nonReentrant returns (uint256) {\n    accrueInterest();\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReservesFresh(uint256 reduceAmount) internal onlyAdmin returns (uint256) {\n    // totalReserves - reduceAmount\n    uint256 totalReservesNew;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      Error.TOKEN_INSUFFICIENT_CASH.fail(FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check reduceAmount  reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      Error.BAD_INPUT.fail(FailureInfo.REDUCE_RESERVES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    totalReservesNew = totalReserves - reduceAmount;\n    // We checked reduceAmount <= totalReserves above, so this should never revert.\n    if (totalReservesNew < totalReserves) {\n      Error.MATH_ERROR.fail(FailureInfo.ADD_RESERVES_UNEXPECTED_OVERFLOW);\n    }\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(admin, reduceAmount);\n\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(address newInterestRateModel) public override returns (uint256) {\n    accrueInterest();\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n   * @dev Admin function to update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModelFresh(address newInterestRateModel) internal onlyAdmin returns (uint256) {\n    // Used to store old model for use in the event that is emitted on success\n    address oldInterestRateModel;\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      Error.MARKET_NOT_FRESH.fail(FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(IInterestRateModel(interestRateModel).isInterestRateModel(), 'MMRF'); // market method returned false\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function _syncUnderlyingBalance() external onlyAdmin {\n    underlyingBalance = ICToken(underlying).balanceOf(address(this));\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying owned by this contract\n   */\n  function getCashPrior() internal view virtual returns (uint256);\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n   *  This may revert due to insufficient balance or insufficient allowance.\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256);\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n   */\n  function doTransferOut(address payable to, uint256 amount) internal virtual;\n\n  function transferToTimelock(bool isBorrow, address to, uint256 amount) internal virtual;\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant() {\n    require(_notEntered, 'RE'); // re-entered\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\n   */\n  function isDeprecated() public view returns (bool) {\n    return\n      IComptroller(comptroller).marketGroupId(address(this)) == 0 &&\n      //borrowGuardianPaused[cToken] == true &&\n      IComptroller(comptroller)._getBorrowPaused(address(this)) &&\n      reserveFactorMantissa == 1e18;\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param repayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowAllowed(\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) public view returns (uint256) {\n    // Shh - currently unused: \n    liquidator;\n    if (!IComptroller(comptroller).isListed(address(this)) || !IComptroller(comptroller).isListed(cTokenCollateral)) {\n      Error.MARKET_NOT_LISTED.fail(FailureInfo.MARKET_NOT_LISTED);\n    }\n\n    (, uint256 borrowBalance) = borrowBalanceStoredInternal(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated()) {\n      if (borrowBalance < repayAmount) {\n        Error.TOKEN_ERROR.fail(FailureInfo.TOO_MUCH_REPAY);\n      }\n    } else {\n      /* The borrower must have shortfall in order to be liquidatable */\n      (, , uint256 shortfall) = IComptroller(comptroller).getHypotheticalAccountLiquidity(\n        borrower,\n        address(this),\n        0,\n        0\n      );\n\n      if (shortfall <= 0) {\n        Error.TOKEN_ERROR.fail(FailureInfo.INSUFFICIENT_SHORTFALL);\n      }\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint256 maxClose = Exp({mantissa: IComptroller(comptroller).closeFactorMantissa()}).mul_ScalarTruncate(\n        borrowBalance\n      );\n      if (repayAmount > maxClose) {\n        Error.TOKEN_ERROR.fail(FailureInfo.TOO_MUCH_REPAY);\n      }\n    }\n    return uint256(0);\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n   * @dev Used in liquidation (called in ICToken(cToken).liquidateBorrowFresh)\n   * @param cTokenCollateral The address of the collateral cToken\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n   */\n  function liquidateCalculateSeizeTokens(\n    address cTokenCollateral,\n    uint256 actualRepayAmount,\n    uint256 liquidationIncentiveMantissa\n  ) public view returns (uint256, uint256) {\n    /* Read oracle prices for borrowed and collateral markets */\n    address oracle = IComptroller(comptroller).oracle();\n    uint256 priceBorrowedMantissa = IPriceOracle(oracle).getUnderlyingPrice(address(address(this)));\n    uint256 priceCollateralMantissa = IPriceOracle(oracle).getUnderlyingPrice(address(cTokenCollateral));\n    if (priceBorrowedMantissa <= 0 || priceCollateralMantissa <= 0) {\n      Error.TOKEN_ERROR.fail(FailureInfo.PRICE_ERROR);\n    }\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    uint256 exchangeRateMantissa = ICToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n    uint256 seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    numerator = Exp({mantissa: liquidationIncentiveMantissa}).mul_(Exp({mantissa: priceBorrowedMantissa}));\n    denominator = Exp({mantissa: priceCollateralMantissa}).mul_(Exp({mantissa: exchangeRateMantissa}));\n    ratio = numerator.div_(denominator);\n\n    seizeTokens = ratio.mul_ScalarTruncate(actualRepayAmount);\n\n    return (uint256(0), seizeTokens);\n  }\n\n  function getAccountBorrows(address account) public view returns (uint256 principal, uint256 interestIndex) {\n    BorrowSnapshot memory accountBorrow = accountBorrows[account];\n    principal = accountBorrow.principal;\n    interestIndex = accountBorrow.interestIndex;\n  }\n\n  function getDiscountRate() public view returns (uint256) {\n    return discountRateMantissa;\n  }\n\n  function _setDiscountRate(uint256 discountRateMantissa_) external returns (uint256) {\n    require(msg.sender == admin, 'UNAUTHORIZED');\n    uint256 oldDiscountRateMantissa_ = discountRateMantissa;\n    discountRateMantissa = discountRateMantissa_;\n    emit NewDiscountRate(oldDiscountRateMantissa_, discountRateMantissa_);\n    return discountRateMantissa;\n  }\n}\n"
    },
    "contracts/CToken/CTokenStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport './Interfaces/ICToken.sol';\n\nabstract contract CTokenStorage is ICToken {\n  bool public isCToken;\n  bool public isCEther;\n  /// @dev Guard variable for re-entrancy checks\n  bool internal _notEntered;\n\n  /// @notice Underlying asset for this CToken\n  address public underlying;\n\n  /// @notice EIP-20 token name for this token\n  string public name;\n\n  /// @notice EIP-20 token symbol for this token\n  string public symbol;\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public decimals;\n\n  /// @dev Maximum borrow rate that can ever be applied (.0005% / block)\n  uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16;\n\n  /// @dev Maximum fraction of interest that can be set aside for reserves\n  uint256 internal constant RESERVE_FACTOR_MAX_MANTISSA = 1e18;\n\n  /// @notice Administrator for this contract\n  address payable public admin;\n\n  /// @notice Pending administrator for this contract\n  address payable public pendingAdmin;\n\n  /// @notice Contract which oversees inter-cToken operations\n  address public comptroller;\n\n  /// @notice Model which tells what the current interest rate should be\n  address public interestRateModel;\n\n  /// @dev Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n  uint256 internal initialExchangeRateMantissa;\n\n  /// @notice Fraction of interest currently set aside for reserves\n  uint256 public reserveFactorMantissa;\n\n  /// @notice Block number that interest was last accrued at\n  uint256 public override accrualBlockNumber;\n\n  /// @notice Accumulator of the total earned interest rate since the opening of the market\n  uint256 public borrowIndex;\n\n  /// @notice Total amount of outstanding borrows of the underlying in this market\n  uint256 public totalBorrows;\n\n  /// @notice Total amount of reserves of the underlying held in this market\n  uint256 public totalReserves;\n\n  /// @notice Total number of tokens in circulation\n  uint256 public override totalSupply;\n\n  /// @dev Official record of token balances for each account\n  mapping(address => uint256) internal accountTokens;\n\n  /// @dev Approved token transfer amounts on behalf of others\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /// @notice Container for borrow balance information\n  /// @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n  /// @member interestIndex Global borrowIndex as of the most recent balance-changing action\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  /// @dev Mapping of account addresses to outstanding borrow balances\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /// @notice Share of seized collateral that is added to reserves\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n  uint256 public discountRateMantissa = 1e18;\n\n  uint256 public underlyingBalance;\n}\n"
    },
    "contracts/CToken/Interfaces/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ICErc20 {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function sweepToken(address token) external;\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n}\n"
    },
    "contracts/CToken/Interfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ICToken {\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Event emitted when comptroller is changed\n   */\n  event NewComptroller(address oldComptroller, address newComptroller);\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n\n  event NewDiscountRate(uint256 oldDiscountRateMantissa, uint256 newDiscountRateMantissa);\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function accrualBlockNumber() external returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel) external returns (uint256);\n\n  function getDiscountRate() external view returns (uint256);\n\n  function _setDiscountRate(uint256 discountRateMantissa) external returns (uint256);\n}\n"
    },
    "contracts/CToken/Interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ninterface IInterestRateModel {\n  function isInterestRateModel() external view returns (bool);\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) external view returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/CToken/TokenErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nenum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    BAD_INPUT,\n    COMPTROLLER_REJECTION,\n    COMPTROLLER_CALCULATION_ERROR,\n    INTEREST_RATE_MODEL_ERROR,\n    INVALID_ACCOUNT_PAIR,\n    INVALID_CLOSE_AMOUNT_REQUESTED,\n    INVALID_COLLATERAL_FACTOR,\n    MATH_ERROR,\n    MARKET_NOT_FRESH,\n    MARKET_NOT_LISTED,\n    TOKEN_INSUFFICIENT_ALLOWANCE,\n    TOKEN_INSUFFICIENT_BALANCE,\n    TOKEN_INSUFFICIENT_CASH,\n    TOKEN_TRANSFER_IN_FAILED,\n    TOKEN_TRANSFER_OUT_FAILED,\n    TOKEN_ERROR\n}\n\n/*\n * Note: FailureInfo (but not Error) is kept in alphabetical order\n *       This is because FailureInfo grows significantly faster, and\n *       the order of Error has some meaning, while the order of FailureInfo\n *       is entirely arbitrary.\n */\nenum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    BORROW_ACCRUE_INTEREST_FAILED,\n    BORROW_CASH_NOT_AVAILABLE,\n    BORROW_FRESHNESS_CHECK,\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    BORROW_MARKET_NOT_LISTED,\n    BORROW_COMPTROLLER_REJECTION,\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n    LIQUIDATE_COMPTROLLER_REJECTION,\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n    LIQUIDATE_FRESHNESS_CHECK,\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_SEIZE_TOO_MUCH,\n    MINT_ACCRUE_INTEREST_FAILED,\n    MINT_COMPTROLLER_REJECTION,\n    MINT_EXCHANGE_CALCULATION_FAILED,\n    MINT_EXCHANGE_RATE_READ_FAILED,\n    MINT_FRESHNESS_CHECK,\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    MINT_TRANSFER_IN_FAILED,\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\n    REDEEM_ACCRUE_INTEREST_FAILED,\n    REDEEM_COMPTROLLER_REJECTION,\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\n    REDEEM_FRESHNESS_CHECK,\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n    REDUCE_RESERVES_ADMIN_CHECK,\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n    REDUCE_RESERVES_FRESH_CHECK,\n    REDUCE_RESERVES_VALIDATION,\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_COMPTROLLER_REJECTION,\n    REPAY_BORROW_FRESHNESS_CHECK,\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COMPTROLLER_OWNER_CHECK,\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_ORACLE_MARKET_NOT_LISTED,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\n    SET_RESERVE_FACTOR_FRESH_CHECK,\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\n    TRANSFER_COMPTROLLER_REJECTION,\n    TRANSFER_NOT_ALLOWED,\n    TRANSFER_NOT_ENOUGH,\n    TRANSFER_TOO_MUCH,\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n    ADD_RESERVES_FRESH_CHECK,\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n    BALANCE_COULD_NOT_BE_CALCULATED,\n    ACCRUE_INTEREST_FAILED, // accrue interest failed\n    BORROW_BALANCE_STORED_INTERNAL_FAILED, // borrowBalanceStored: borrowBalanceStoredInternal failed\n    EXCHANGE_RATE_STORED_INTERNAL_FAILED,\n    BORROW_RATE_ABSURDLY_HIGH,\n    COULD_NOT_CACULATE_BLOCK_DELTA,\n    ONE_OF_REDEEM_TOKENS_IN_OR_REDEEM_AMOUNT_IN_MUST_BE_ZERO,\n    PRICE_ERROR,\n    ADD_RESERVES_UNEXPECTED_OVERFLOW,\n    MARKET_NOT_LISTED,\n    TOO_MUCH_REPAY,\n    INSUFFICIENT_SHORTFALL\n}\n\nlibrary TokenErrorReporter {\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    error TokenError(uint256 errorCode, uint256 infoCode, uint256 detailCode);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal pure returns (uint256) {\n        // emit Failure(uint256(err), uint256(info), 0);\n        revert TokenError(uint256(err), uint256(info), 0);\n        // return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal pure returns (uint256) {\n        // emit Failure(uint256(err), uint256(info), opaqueError);\n        revert TokenError(uint256(err), uint256(info), opaqueError);\n        // return uint256(err);\n    }\n}\n"
    },
    "contracts/Exponential/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/**\n * @dev Possible error codes that we can return\n */\nenum MathError {\n  NO_ERROR,\n  DIVISION_BY_ZERO,\n  INTEGER_OVERFLOW,\n  INTEGER_UNDERFLOW\n}\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\nlibrary CarefulMath {\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint256 c = a * b;\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    uint256 c = a + b;\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint256 a,\n    uint256 b,\n    uint256 c\n  ) internal pure returns (MathError, uint256) {\n    (MathError err0, uint256 sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n}\n"
    },
    "contracts/Exponential/Exponential.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport '../Exponential/ExponentialNoError.sol';\nimport './CarefulMath.sol';\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\nlibrary Exponential {\n  uint256 constant expScale = 1e18;\n  uint256 constant halfExpScale = expScale / 2;\n  using CarefulMath for uint256;\n  using ExponentialNoError for Exp;\n\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledNumerator) = num.mulUInt(expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    (MathError err1, uint256 rational) = scaledNumerator.divUInt(denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: rational}));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = a.mantissa.addUInt(b.mantissa);\n\n    return (error, Exp({mantissa: result}));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = a.mantissa.subUInt(b.mantissa);\n\n    return (error, Exp({mantissa: result}));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledMantissa) = a.mantissa.mulUInt(scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, product.truncate());\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mulScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return product.truncate().addUInt(addend);\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 descaledMantissa) = a.mantissa.divUInt(scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint256 numerator) = expScale.mulUInt(scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, fraction.truncate());\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 doubleScaledProduct) = a.mantissa.mulUInt(b.mantissa);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({mantissa: 0}));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = halfExpScale.addUInt(doubleScaledProduct);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({mantissa: 0}));\n    }\n\n    (MathError err2, uint256 product) = doubleScaledProductWithHalfScale.divUInt(expScale);\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({mantissa: product}));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n    return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/Exponential/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nstruct Exp {\n  uint256 mantissa;\n}\n\nstruct Double {\n  uint256 mantissa;\n}\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\nlibrary ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add_(a, b, 'addition overflow');\n  }\n\n  function add_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub_(a, b, 'subtraction underflow');\n  }\n\n  function sub_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mul_(a, b, 'multiplication overflow');\n  }\n\n  function mul_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div_(a, b, 'divide by zero');\n  }\n\n  function div_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\n  }\n}\n"
    },
    "contracts/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ITimelock {\n  /** @notice Event emitted when a new time-lock agreement is created\n   * @param agreementId ID of the created agreement\n   * @param actionType Type of action for the time-lock\n   * @param asset Address of the asset\n   * @param amount  amount\n   * @param beneficiary Address of the beneficiary\n   * @param releaseTime Timestamp when the assets can be claimed\n   */\n  event AgreementCreated(\n    uint256 agreementId,\n    TimeLockActionType actionType,\n    address indexed asset,\n    uint256 amount,\n    address indexed beneficiary,\n    uint256 releaseTime\n  );\n\n  /** @notice Event emitted when a time-lock agreement is claimed\n   * @param agreementId ID of the claimed agreement\n   * @param actionType Type of action for the time-lock\n   * @param asset Address of the asset\n   * @param amount amount\n   * @param beneficiary Address of the beneficiary\n   */\n  event AgreementClaimed(\n    uint256 agreementId,\n    TimeLockActionType actionType,\n    address indexed asset,\n    uint256 amount,\n    address indexed beneficiary\n  );\n\n  /** @notice Event emitted when a time-lock agreement is frozen or unfrozen\n   * @param agreementId ID of the affected agreement\n   * @param value Indicates whether the agreement is frozen (true) or unfrozen (false)\n   */\n  event AgreementFrozen(uint256 agreementId, bool value);\n\n  /** @notice Event emitted when the entire TimeLock contract is frozen or unfrozen\n   * @param value Indicates whether the contract is frozen (true) or unfrozen (false)\n   */\n  event TimeLockFrozen(bool value);\n\n  /**\n   * @dev Emitted during rescueERC20()\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount being rescued\n   **/\n  event RescueERC20(address indexed token, address indexed to, uint256 amount);\n\n  enum TimeLockActionType {\n    BORROW,\n    REDEEM\n  }\n  struct Agreement {\n    uint256 agreementId;\n    TimeLockActionType actionType;\n    address underlying;\n    bool isFrozen;\n    address beneficiary;\n    uint256 releaseTime;\n    uint256 amount;\n  }\n\n  struct Underlying {\n    address cToken;\n    uint256 totalBalance;\n    uint256 lockDuration;\n    bool isSupport;\n  }\n\n  function createAgreement(\n    TimeLockActionType actionType,\n    address underlying,\n    uint256 amount,\n    address beneficiary\n  ) external returns (uint256);\n\n  function isSupport(address underlying) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}