{
  "language": "Solidity",
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata", "storageLayout"]
      }
    }
  },
  "sources": {
    "contracts/Comptroller/CompoundLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport './Interfaces/ICToken.sol';\nimport './Interfaces/IPriceOracle.sol';\nimport './Interfaces/IGovernorAlpha.sol';\nimport './Interfaces/IComptroller.sol';\nimport './Interfaces/IGovernorBravo.sol';\nimport './Interfaces/IUnderwriterAdmin.sol';\nimport '../Exponential/ExponentialNoError.sol';\nimport './ComptrollerStorage.sol';\n\ncontract CompoundLens {\n  using ExponentialNoError for uint256;\n  using ExponentialNoError for Exp;\n  using ExponentialNoError for Double;\n  struct CTokenMetadata {\n    address cToken;\n    uint256 exchangeRateCurrent;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 reserveFactorMantissa;\n    uint256 totalBorrows;\n    uint256 totalReserves;\n    uint256 totalSupply;\n    uint256 totalCash;\n    bool isListed;\n    // uint256 collateralFactorMantissa;\n    address underlyingAssetAddress;\n    uint256 cTokenDecimals;\n    uint256 underlyingDecimals;\n    bool isCToken;\n    bool isCEther;\n    uint256 borrowCap;\n    uint256 depositCap;\n    uint256 liquidationIncentive;\n    uint8 groupId;\n    uint256 intraRate;\n    uint256 mintRate;\n    uint256 interRate;\n    uint256 discountRate;\n  }\n\n  struct GroupInfo {\n    uint256 intraRate;\n    uint256 mintRate;\n    uint256 interRate;\n  }\n\n  function cTokenMetadata(ICToken cToken) public returns (CTokenMetadata memory) {\n    IComptroller comptroller = IComptroller(address(cToken.comptroller()));\n    IUnderwriterAdmin ua = IUnderwriterAdmin(comptroller.underWriterAdmin());\n\n    // get underlying info\n    address underlyingAssetAddress;\n    uint256 underlyingDecimals;\n    if (cToken.isCEther()) {\n      underlyingAssetAddress = address(0);\n      underlyingDecimals = 18;\n    } else {\n      underlyingAssetAddress = cToken.underlying();\n      underlyingDecimals = ICToken(cToken.underlying()).decimals();\n    }\n\n    // get group info\n    (bool isListed, uint8 assetGroupId, ) = comptroller.markets(address(cToken));\n    IUnderwriterAdmin.AssetGroup memory group = ua.getAssetGroup(assetGroupId);\n    GroupInfo memory gi;\n    if (cToken.isCToken()) {\n      gi.intraRate = group.intraCRateMantissa;\n      gi.interRate = group.interCRateMantissa;\n      gi.mintRate = group.intraMintRateMantissa;\n    } else {\n      gi.intraRate = group.intraSuRateMantissa;\n      gi.interRate = group.interSuRateMantissa;\n      gi.mintRate = group.intraSuRateMantissa;\n    }\n\n    return\n      CTokenMetadata({\n        cToken: address(cToken),\n        exchangeRateCurrent: cToken.exchangeRateCurrent(),\n        supplyRatePerBlock: cToken.supplyRatePerBlock(),\n        borrowRatePerBlock: cToken.borrowRatePerBlock(),\n        reserveFactorMantissa: cToken.reserveFactorMantissa(),\n        totalBorrows: cToken.totalBorrows(),\n        totalReserves: cToken.totalReserves(),\n        totalSupply: cToken.totalSupply(),\n        totalCash: cToken.getCash(),\n        isListed: isListed,\n        underlyingAssetAddress: underlyingAssetAddress,\n        cTokenDecimals: cToken.decimals(),\n        underlyingDecimals: underlyingDecimals,\n        isCToken: cToken.isCToken(),\n        isCEther: cToken.isCEther(),\n        borrowCap: ua._getMarketBorrowCap(address(cToken)),\n        depositCap: ComptrollerStorage(address(comptroller)).maxSupply(address(cToken)),\n        liquidationIncentive: comptroller.liquidationIncentiveMantissa(),\n        groupId: assetGroupId,\n        intraRate: gi.intraRate,\n        interRate: gi.interRate,\n        mintRate: gi.mintRate,\n        discountRate: cToken.getDiscountRate()\n      });\n  }\n\n  function cTokenMetadataAll(ICToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenMetadata(cTokens[i]);\n    }\n    return res;\n  }\n\n  struct CTokenBalances {\n    address cToken;\n    bool isCToken;\n    bool isCEther;\n    uint256 balanceOf;\n    uint256 borrowBalanceCurrent;\n    uint256 balanceOfUnderlying;\n    uint256 tokenBalance;\n    uint256 tokenAllowance;\n  }\n\n  function cTokenBalances(ICToken cToken, address payable account) public returns (CTokenBalances memory) {\n    uint256 balanceOf = cToken.balanceOf(account);\n    uint256 borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\n    uint256 balanceOfUnderlying = cToken.balanceOfUnderlying(account);\n    uint256 tokenBalance;\n    uint256 tokenAllowance;\n\n    if (cToken.isCEther()) {\n      tokenBalance = account.balance;\n      tokenAllowance = account.balance;\n    } else {\n      ICToken underlying = ICToken(cToken.underlying());\n      tokenBalance = underlying.balanceOf(account);\n      tokenAllowance = underlying.allowance(account, address(cToken));\n    }\n\n    return\n      CTokenBalances({\n        cToken: address(cToken),\n        isCToken: cToken.isCToken(),\n        isCEther: cToken.isCEther(),\n        balanceOf: balanceOf,\n        borrowBalanceCurrent: borrowBalanceCurrent,\n        balanceOfUnderlying: balanceOfUnderlying,\n        tokenBalance: tokenBalance,\n        tokenAllowance: tokenAllowance\n      });\n  }\n\n  function cTokenBalancesAll(\n    ICToken[] calldata cTokens,\n    address payable account\n  ) external returns (CTokenBalances[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenBalances(cTokens[i], account);\n    }\n    return res;\n  }\n\n  struct CTokenUnderlyingPrice {\n    address cToken;\n    uint256 underlyingPrice;\n  }\n\n  function cTokenUnderlyingPrice(ICToken cToken) public view returns (CTokenUnderlyingPrice memory) {\n    IComptroller comptroller = IComptroller(address(cToken.comptroller()));\n    IPriceOracle priceOracle = IPriceOracle(comptroller.oracle());\n\n    return\n      CTokenUnderlyingPrice({\n        cToken: address(cToken),\n        underlyingPrice: priceOracle.getUnderlyingPrice(address(cToken))\n      });\n  }\n\n  function cTokenUnderlyingPriceAll(ICToken[] calldata cTokens) external view returns (CTokenUnderlyingPrice[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenUnderlyingPrice(cTokens[i]);\n    }\n    return res;\n  }\n\n  struct AccountLimits {\n    address[] markets;\n    uint256 liquidity;\n    uint256 shortfall;\n  }\n\n  function getAccountLimits(IComptroller comptroller, address account) public returns (AccountLimits memory) {\n    (uint256 errorCode, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(account);\n    require(errorCode == 0);\n\n    return AccountLimits({markets: comptroller.getAssetsIn(account), liquidity: liquidity, shortfall: shortfall});\n  }\n\n  struct GovReceipt {\n    uint256 proposalId;\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  function getGovReceipts(\n    IGovernorAlpha governor,\n    address voter,\n    uint256[] memory proposalIds\n  ) public view returns (GovReceipt[] memory) {\n    uint256 proposalCount = proposalIds.length;\n    GovReceipt[] memory res = new GovReceipt[](proposalCount);\n    for (uint256 i = 0; i < proposalCount; i++) {\n      IGovernorAlpha.Receipt memory receipt;\n\n      (receipt.hasVoted, receipt.support, receipt.votes) = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovReceipt({\n        proposalId: proposalIds[i],\n        hasVoted: receipt.hasVoted,\n        support: receipt.support,\n        votes: receipt.votes\n      });\n    }\n    return res;\n  }\n\n  struct GovBravoReceipt {\n    uint256 proposalId;\n    bool hasVoted;\n    uint8 support;\n    uint96 votes;\n  }\n\n  function getGovBravoReceipts(\n    IGovernorBravo governor,\n    address voter,\n    uint256[] memory proposalIds\n  ) public view returns (GovBravoReceipt[] memory) {\n    uint256 proposalCount = proposalIds.length;\n    GovBravoReceipt[] memory res = new GovBravoReceipt[](proposalCount);\n    for (uint256 i = 0; i < proposalCount; i++) {\n      IGovernorBravo.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovBravoReceipt({\n        proposalId: proposalIds[i],\n        hasVoted: receipt.hasVoted,\n        support: receipt.support,\n        votes: receipt.votes\n      });\n    }\n    return res;\n  }\n\n  struct GovProposal {\n    uint256 proposalId;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setProposal(GovProposal memory res, IGovernorAlpha governor, uint256 proposalId) internal view {\n    (\n      ,\n      address proposer,\n      uint256 eta,\n      uint256 startBlock,\n      uint256 endBlock,\n      uint256 forVotes,\n      uint256 againstVotes,\n      bool canceled,\n      bool executed\n    ) = governor.proposals(proposalId);\n    res.proposalId = proposalId;\n    res.proposer = proposer;\n    res.eta = eta;\n    res.startBlock = startBlock;\n    res.endBlock = endBlock;\n    res.forVotes = forVotes;\n    res.againstVotes = againstVotes;\n    res.canceled = canceled;\n    res.executed = executed;\n  }\n\n  function getGovProposals(\n    IGovernorAlpha governor,\n    uint256[] calldata proposalIds\n  ) external view returns (GovProposal[] memory) {\n    GovProposal[] memory res = new GovProposal[](proposalIds.length);\n    for (uint256 i = 0; i < proposalIds.length; i++) {\n      (\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n      ) = governor.getActions(proposalIds[i]);\n      res[i] = GovProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct GovBravoProposal {\n    uint256 proposalId;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    uint256 abstainVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setBravoProposal(GovBravoProposal memory res, IGovernorBravo governor, uint256 proposalId) internal view {\n    IGovernorBravo.Proposal memory p = governor.proposals(proposalId);\n\n    res.proposalId = proposalId;\n    res.proposer = p.proposer;\n    res.eta = p.eta;\n    res.startBlock = p.startBlock;\n    res.endBlock = p.endBlock;\n    res.forVotes = p.forVotes;\n    res.againstVotes = p.againstVotes;\n    res.abstainVotes = p.abstainVotes;\n    res.canceled = p.canceled;\n    res.executed = p.executed;\n  }\n\n  function getGovBravoProposals(\n    IGovernorBravo governor,\n    uint256[] calldata proposalIds\n  ) external view returns (GovBravoProposal[] memory) {\n    GovBravoProposal[] memory res = new GovBravoProposal[](proposalIds.length);\n    for (uint256 i = 0; i < proposalIds.length; i++) {\n      (\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n      ) = governor.getActions(proposalIds[i]);\n      res[i] = GovBravoProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        abstainVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setBravoProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct CompBalanceMetadata {\n    uint256 balance;\n    uint256 votes;\n    address delegate;\n  }\n\n  function getCompBalanceMetadata(ICToken comp, address account) external view returns (CompBalanceMetadata memory) {\n    return\n      CompBalanceMetadata({\n        balance: comp.balanceOf(account),\n        votes: uint256(comp.getCurrentVotes(account)),\n        delegate: comp.delegates(account)\n      });\n  }\n\n  struct CompBalanceMetadataExt {\n    uint256 balance;\n    uint256 votes;\n    address delegate;\n    uint256 allocated;\n  }\n\n  function getCompBalanceMetadataExt(\n    ICToken comp,\n    IComptroller comptroller,\n    address account\n  ) external returns (CompBalanceMetadataExt memory) {\n    uint256 balance = comp.balanceOf(account);\n    comptroller.claimComp(account);\n    uint256 newBalance = comp.balanceOf(account);\n    uint256 accrued = comptroller.compAccrued(account);\n    uint256 total = add(accrued, newBalance, 'sum comp total');\n    uint256 allocated = sub(total, balance, 'sub allocated');\n\n    return\n      CompBalanceMetadataExt({\n        balance: balance,\n        votes: uint256(comp.getCurrentVotes(account)),\n        delegate: comp.delegates(account),\n        allocated: allocated\n      });\n  }\n\n  struct CompVotes {\n    uint256 blockNumber;\n    uint256 votes;\n  }\n\n  function getCompVotes(\n    ICToken comp,\n    address account,\n    uint32[] calldata blockNumbers\n  ) external view returns (CompVotes[] memory) {\n    CompVotes[] memory res = new CompVotes[](blockNumbers.length);\n    for (uint256 i = 0; i < blockNumbers.length; i++) {\n      res[i] = CompVotes({\n        blockNumber: uint256(blockNumbers[i]),\n        votes: uint256(comp.getPriorVotes(account, blockNumbers[i]))\n      });\n    }\n    return res;\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n   * @dev Used in liquidation (called in ICToken(cToken).liquidateBorrowFresh)\n   * @param cTokenBorrowed The address of the borrowed cToken\n   * @param cTokenCollateral The address of the collateral cToken\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n   */\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 actualRepayAmount,\n    IComptroller comptroller\n  ) external view returns (uint256, uint256) {\n    /* Read oracle prices for borrowed and collateral markets */\n    address oracle = comptroller.oracle();\n    uint256 priceBorrowedMantissa = IPriceOracle(oracle).getUnderlyingPrice(address(cTokenBorrowed));\n    uint256 priceCollateralMantissa = IPriceOracle(oracle).getUnderlyingPrice(address(cTokenCollateral));\n    require(priceBorrowedMantissa > 0 && priceCollateralMantissa > 0, 'PRICE_ERROR');\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    uint256 exchangeRateMantissa = ICToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n    uint256 seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    numerator = Exp({mantissa: comptroller.liquidationIncentiveMantissa()}).mul_(\n      Exp({mantissa: priceBorrowedMantissa})\n    );\n    denominator = Exp({mantissa: priceCollateralMantissa}).mul_(Exp({mantissa: exchangeRateMantissa}));\n    ratio = numerator.div_(denominator);\n\n    seizeTokens = ratio.mul_ScalarTruncate(actualRepayAmount);\n\n    return (uint256(0), seizeTokens);\n  }\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\n   * @param cToken The market to check if deprecated\n   */\n  function isDeprecated(address cToken, IComptroller comptroller) public view returns (bool) {\n    return\n      comptroller.marketGroupId(cToken) == 0 &&\n      //borrowGuardianPaused[cToken] == true &&\n      IUnderwriterAdmin(comptroller.underWriterAdmin())._getBorrowPaused(cToken) &&\n      ICToken(cToken).reserveFactorMantissa() == 1e18;\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param repayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    IComptroller comptroller\n  ) external view returns (uint256) {\n    // Shh - currently unused: liquidator;\n\n    require(comptroller.isListed(cTokenBorrowed) && comptroller.isListed(cTokenCollateral), 'MARKET_NOT_LISTED');\n\n    uint256 borrowBalance = ICToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated(cTokenBorrowed, comptroller)) {\n      require(borrowBalance >= repayAmount, 'too much repay');\n    } else {\n      /* The borrower must have shortfall in order to be liquidatable */\n      (, , uint256 shortfall) = comptroller.getHypotheticalAccountLiquidity(borrower, cTokenBorrowed, 0, 0);\n\n      require(shortfall > 0, 'insufficient shortfall');\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint256 maxClose = Exp({mantissa: comptroller.closeFactorMantissa()}).mul_ScalarTruncate(borrowBalance);\n      require(repayAmount <= maxClose, 'too much repay');\n    }\n    return uint256(0);\n  }\n}\n"
    },
    "contracts/Comptroller/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ncontract ComptrollerStorage {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    string internal constant INSUFFICIENT_LIQUIDITY = \"insufficient liquidity\";\n    string internal constant MARKET_NOT_LISTED = \"market not listed\";\n    string internal constant UNAUTHORIZED = \"unauthorized\";\n    string internal constant PRICE_ERROR = \"price error\";\n    string internal constant SNAPSHOT_ERROR = \"snapshot error\";\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => address[]) public accountAssets;\n    /// @notice Whether or not this market is listed\n    /// @notice Per-market mapping of \"accounts in this asset\"\n    /// @notice Whether or not this market receives COMP\n    struct Market {\n        bool isListed;\n        uint8 assetGroupId;\n        mapping(address => bool) accountMembership;\n        bool isComped;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    address[] public allMarkets;\n\n    mapping(address => uint256) public maxSupply;\n\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(address cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(address cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(address cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(\n        uint256 oldCloseFactorMantissa,\n        uint256 newCloseFactorMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n\n    event SetMaxSupply(address indexed cToken, uint256 amount);\n}\n"
    },
    "contracts/Exponential/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nstruct Exp {\n  uint256 mantissa;\n}\n\nstruct Double {\n  uint256 mantissa;\n}\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\nlibrary ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add_(a, b, 'addition overflow');\n  }\n\n  function add_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub_(a, b, 'subtraction underflow');\n  }\n\n  function sub_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mul_(a, b, 'multiplication overflow');\n  }\n\n  function mul_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div_(a, b, 'divide by zero');\n  }\n\n  function div_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\n  }\n}\n"
    },
    "contracts/Comptroller/Interfaces/IUnderwriterAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IUnderwriterAdmin {\n  /// @notice Emitted when an action is paused on a market\n  event ActionPaused(address cToken, string action, bool pauseState);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(address indexed cToken, uint256 newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  event NewAssetGroup(\n    uint8 indexed groupId,\n    string indexed groupName,\n    uint256 intraCRateMantissa,\n    uint256 intraMintRateMantissa,\n    uint256 intraSuRateMantissa,\n    uint256 interCRateMantissa,\n    uint256 interSuRateMantissa,\n    uint8 assetsGroupNum\n  );\n\n  event RemoveAssetGroup(uint8 indexed groupId, uint8 equalAssetsGroupNum);\n\n  /// @notice AssetGroup, contains information of groupName and rateMantissas\n  struct AssetGroup {\n    uint8 groupId;\n    string groupName;\n    uint256 intraCRateMantissa;\n    uint256 intraMintRateMantissa;\n    uint256 intraSuRateMantissa;\n    uint256 interCRateMantissa;\n    uint256 interSuRateMantissa;\n  }\n\n  function getAssetGroupNum() external view returns (uint8);\n\n  function getAssetGroup(uint8 groupId) external view returns (AssetGroup memory);\n\n  function _getMintPaused(address cToken) external returns (bool);\n\n  function _getTransferPaused() external view returns (bool);\n\n  function _getBorrowPaused(address cToken) external view returns (bool);\n\n  function _getSeizePaused() external view returns (bool);\n\n  function getCompAddress() external view returns (address);\n\n  function _getMarketBorrowCap(address cToken) external view returns (uint256);\n\n}\n"
    },
    "contracts/Comptroller/Interfaces/IGovernorBravo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IGovernorBravo {\n  struct Receipt {\n    bool hasVoted;\n    uint8 support;\n    uint96 votes;\n  }\n  struct Proposal {\n    uint256 id;\n    address proposer;\n    uint256 eta;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    uint256 abstainVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function getActions(uint256 proposalId)\n    external\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n\n  function proposals(uint256 proposalId) external view returns (Proposal memory);\n\n  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n}\n"
    },
    "contracts/Comptroller/Interfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IComptroller {\n  /*** Assets You Are In ***/\n  function isComptroller() external view returns (bool);\n\n  function markets(address) external view returns (bool, uint8, bool);\n\n  function getAllMarkets() external view returns (address[] memory);\n\n  function oracle() external view returns (address);\n\n  function underWriterAdmin() external view returns (address);\n\n  function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n  function exitMarket(address cToken) external returns (uint256);\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function getAccountLiquidity(address) external view returns (uint256, uint256, uint256);\n\n  // function getAssetsIn(address) external view returns (ICToken[] memory);\n  function claimComp(address) external;\n\n  function compAccrued(address) external view returns (uint256);\n\n  function getAssetsIn(address account) external view returns (address[] memory);\n\n  function timelock() external view returns (address);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external returns (uint256);\n\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n  function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external returns (uint256);\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function isListed(address asset) external view returns (bool);\n\n  function marketGroupId(address asset) external view returns (uint8);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  ) external view returns (uint256, uint256, uint256);\n\n  function _getMarketBorrowCap(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Interfaces/IGovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nabstract contract IGovernorAlpha {\n  struct Proposal {\n    // Unique id for looking up a proposal\n    uint256 id;\n    // Creator of the proposal\n    address proposer;\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    // the ordered list of target addresses for calls to be made\n    address[] targets;\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    // The ordered list of function signatures to be called\n    string[] signatures;\n    // The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    // The block at which voting begins: holders must delegate their votes prior to this block\n    uint256 startBlock;\n    // The block at which voting ends: votes must be cast prior to this block\n    uint256 endBlock;\n    // Current number of votes in favor of this proposal\n    uint256 forVotes;\n    // Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    // Flag marking whether the proposal has been canceled\n    bool canceled;\n    // Flag marking whether the proposal has been executed\n    bool executed;\n    // Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n  // Ballot receipt record for a voter\n  // Whether or not a vote has been cast\n  // Whether or not the voter supports the proposal\n  // The number of votes the voter had, which were cast\n  struct Receipt {\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  function getReceipt(uint256 proposalId, address voter)\n    external\n    view\n    virtual\n    returns (\n      bool,\n      bool,\n      uint96\n    );\n\n  mapping(uint256 => Proposal) public proposals;\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    virtual\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n}\n"
    },
    "contracts/Comptroller/Interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IPriceOracle {\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n"
    },
    "contracts/Comptroller/Interfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ICToken {\n  function comptroller() external view returns (address);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function isCToken() external view returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function isCEther() external view returns (bool);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function decimals() external view returns (uint8);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function getCurrentVotes(address account) external view returns (uint96);\n\n  function delegates(address) external view returns (address);\n\n  function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n  function getDiscountRate() external view returns (uint256);\n}\n"
    }
  }
}
